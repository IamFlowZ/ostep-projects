1.) The CPU Utilization while running two sets of five commands with 100% chance of being CPU based will be 100%.
2.) This will take 10 units of time. CPU commands are shown as consuming one unit of time while I/O commands take five units and every process issues a final DONE command once all child processes are complete.. With I/O events issue one command to instruct the processor to start the I/O event, and spend four cycles waiting for the event to complete.
3.) Switching the order these processes run in will result in less cycles being needed to complete the whole process (6). With the I/O event being ran last, the CPU has to wait for it to complete before handing control back to the operating system thus wasting cycles. If we first start the I/O event, and then run the CPU events, the CPU can run them while waiting for the I/O to return. Then once all events are complete, it can return control back to the OS.
4.) This configuration will result in the one less cycle being consumed as the first example (9), assuming that I/O will take five cycles to run to completion and will hand the process over to any other events in the cycle that the I/O event is finished.
5.) With the I/O process now being configured to pass CPU control while waiting, we should see a number of cycles being used similar to question three (6).
6.) System resources where not being used effectively with this configuration. Out of 27 cycles, eight of them the CPU was being unused while I/O occured. Not only was the CPU not being used, but all three sets of CPU events occurred after the first I/O event and before the second two. Meaning that we could have utilized the other two I/O events to run our CPU tasks. 
7.) Now the pure CPU events were ran concurrently with most of the I/O events, with only a handful of CPU events trailing behind. Running an I/O process multiple times might be beneficial in that they are asynchronus events. So we're typically offloading data to some other source from our program, so it's not neccessary to block our program from running while things outside of it's control take place.
8.) The "IO_RUN_LATER" flag will cause any I/O events to be ran as late as possible, while the "IO_RUN_IMMEDIATE" will continue queueing I/O events as often as possible. The "SWITCH_ON_IO" flag will switch to a different process once an I/O command is issued, while the "SWITCH_ON_END" flag will only switch to a seperate process once a the current process is finished. The combination of these two flags that will take the shortest amount of cycles to complete will typically be "IO_RUN_IMMEDIATE" along with "SWITCH_ON_IO", due to I/O events being set to never hog cycles while they wait on exterior events. And "IO_RUN_LATER" with "SWITCH_ON_END" will typically result in the most cycles being consumed due to the blocking nature of not switching until all tasks in the process are completed, and all I/O events not allowing other events to run while they are waiting on exterior events. 
